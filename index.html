<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Naves Espaciais</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
    body {
        margin: 0;
        background: radial-gradient(#000015, #000000);
        overflow: hidden;
        touch-action: none;
    }
    canvas {
        position: fixed;
        top: 0;
        left: 0;
    }
</style>
</head>
<body>

<canvas id="game"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

function resize() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
}
resize();
window.onresize = resize;

let ships = [];
let explosions = [];

// ðŸŽ¨ DESENHA UMA NAVE ESPACIAL GIRANDO (gerada via canvas)
function generateShip(size) {
    const off = document.createElement("canvas");
    off.width = size * 2;
    off.height = size * 2;
    const octx = off.getContext("2d");

    // corpo
    octx.fillStyle = "#888";
    octx.beginPath();
    octx.ellipse(size, size, size * 0.7, size * 1.1, 0, 0, Math.PI * 2);
    octx.fill();

    // cabine azul
    const grad = octx.createRadialGradient(size, size * 0.8, 5, size, size * 0.8, size * 0.5);
    grad.addColorStop(0, "#aeeaff");
    grad.addColorStop(1, "#003355");

    octx.fillStyle = grad;
    octx.beginPath();
    octx.ellipse(size, size * 0.8, size * 0.4, size * 0.3, 0, 0, Math.PI * 2);
    octx.fill();

    // luzes da nave
    for (let i = 0; i < 6; i++) {
        const angle = (i / 6) * Math.PI * 2;
        const lx = size + Math.cos(angle) * size * 0.7;
        const ly = size + Math.sin(angle) * size * 0.7;
        octx.fillStyle = ["#ff3333", "#33ff33", "#ffff33"][i % 3];
        octx.beginPath();
        octx.arc(lx, ly, size * 0.12, 0, Math.PI * 2);
        octx.fill();
    }

    return off;
}

function spawnShip() {
    const size = 30 + Math.random() * 35;
    ships.push({
        x: Math.random() * canvas.width,
        y: -80,
        size,
        speed: 2 + Math.random() * 4,
        angle: Math.random() * 0.4 - 0.2,
        rot: Math.random() * Math.PI,
        rotSpeed: Math.random() * 0.1 - 0.05,
        ship: generateShip(size)
    });
}

setInterval(spawnShip, 600);

// ðŸ’¥ explosÃ£o aprimorada
function explode(x, y) {
    for (let i = 0; i < 40; i++) {
        explosions.push({
            x, y,
            dx: (Math.random() - 0.5) * 10,
            dy: (Math.random() - 0.5) * 10,
            size: 4 + Math.random() * 6,
            alpha: 1
        });
    }

    if (navigator.vibrate) navigator.vibrate(150);
}

// toque/clique
function checkHit(x, y) {
    for (let i = ships.length - 1; i >= 0; i--) {
        const s = ships[i];
        const dx = x - s.x;
        const dy = y - s.y;
        if (Math.sqrt(dx * dx + dy * dy) < s.size) {
            explode(s.x, s.y);
            ships.splice(i, 1);
            break;
        }
    }
}

canvas.addEventListener("touchstart", e => {
    const t = e.touches[0];
    checkHit(t.clientX, t.clientY);
});

canvas.addEventListener("mousedown", e => {
    checkHit(e.clientX, e.clientY);
});

// Rastro de luz futurista
function drawLightTrail(s) {
    const tail = s.size * 4;

    const grad = ctx.createLinearGradient(
        s.x, s.y,
        s.x - s.angle * tail,
        s.y - tail
    );

    grad.addColorStop(0, "rgba(0,200,255,0.7)");
    grad.addColorStop(0.5, "rgba(0,80,255,0.3)");
    grad.addColorStop(1, "rgba(0,0,0,0)");

    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.moveTo(s.x, s.y);
    ctx.lineTo(s.x - s.angle * tail + s.size, s.y - tail);
    ctx.lineTo(s.x - s.angle * tail - s.size, s.y - tail);
    ctx.closePath();
    ctx.fill();
}

// desenha nave
function drawShip(s) {
    drawLightTrail(s);

    ctx.save();
    ctx.translate(s.x, s.y);
    ctx.rotate(s.rot);
    ctx.drawImage(
        s.ship,
        -s.size,
        -s.size,
        s.size * 2,
        s.size * 2
    );
    ctx.restore();
}

// explosÃ£o
function drawExplosion(e) {
    ctx.globalAlpha = e.alpha;
    ctx.fillStyle = "orange";
    ctx.beginPath();
    ctx.arc(e.x, e.y, e.size, 0, Math.PI * 2);
    ctx.fill();
    ctx.globalAlpha = 1;
}

function loop() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    ships.forEach(s => {
        s.y += s.speed;
        s.x += s.angle * 4;
        s.rot += s.rotSpeed;

        drawShip(s);
    });

    ships = ships.filter(s => s.y < canvas.height + 100);

    explosions.forEach(e => {
        e.x += e.dx;
        e.y += e.dy;
        e.alpha -= 0.03;
        drawExplosion(e);
    });

    explosions = explosions.filter(e => e.alpha > 0);

    requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>