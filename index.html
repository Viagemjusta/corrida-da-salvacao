<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo 3D básico com joystick</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #000;
    touch-action: none;
  }
  #joystick {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 120px;
    height: 120px;
    background: rgba(255,255,255,0.15);
    border-radius: 50%;
    touch-action: none;
  }
  #knob {
    position: absolute;
    left: 40px; top: 40px;
    width: 40px; height: 40px;
    background: rgba(255,255,255,0.5);
    border-radius: 50%;
    touch-action: none;
  }
</style>
</head>
<body>

<div id="joystick">
  <div id="knob"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
  // Setup básico Three.js
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luz básica
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5, 10, 7);
  scene.add(light);

  // Cubo personagem
  const geometry = new THREE.BoxGeometry(1,1,1);
  const material = new THREE.MeshStandardMaterial({color: 0x00ff00});
  const player = new THREE.Mesh(geometry, material);
  scene.add(player);

  player.position.z = 0;
  player.position.y = 0;
  player.position.x = 0;

  camera.position.z = 5;
  camera.position.y = 2;
  camera.lookAt(player.position);

  // Obstáculos (esferas vermelhas)
  const obstacles = [];
  const obstacleGeometry = new THREE.SphereGeometry(0.3, 16, 16);
  const obstacleMaterial = new THREE.MeshStandardMaterial({color: 0xff0000});

  function spawnObstacle() {
    const obs = new THREE.Mesh(obstacleGeometry, obstacleMaterial);
    obs.position.x = (Math.random() - 0.5) * 10;
    obs.position.y = 0;
    obs.position.z = -20;
    scene.add(obs);
    obstacles.push(obs);
  }

  setInterval(spawnObstacle, 1500);

  // Joystick
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('knob');
  let dragging = false;
  let startX = 0, startY = 0;
  let deltaX = 0, deltaY = 0;

  joystick.addEventListener('touchstart', e => {
    dragging = true;
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
  }, {passive:false});

  joystick.addEventListener('touchmove', e => {
    if(!dragging) return;
    const touch = e.touches[0];
    deltaX = touch.clientX - startX;
    deltaY = touch.clientY - startY;

    // Limita o knob ao círculo do joystick
    const maxDist = joystick.clientWidth/2 - knob.clientWidth/2;
    let dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
    if(dist > maxDist){
      deltaX = deltaX * maxDist / dist;
      deltaY = deltaY * maxDist / dist;
    }

    knob.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

    e.preventDefault();
  }, {passive:false});

  joystick.addEventListener('touchend', e => {
    dragging = false;
    deltaX = 0;
    deltaY = 0;
    knob.style.transform = `translate(0px, 0px)`;
  });

  // Velocidade do player
  const speed = 0.05;

  // Loop do jogo
  function animate(){
    requestAnimationFrame(animate);

    // Move player baseado no joystick (normaliza movimento para ficar proporcional)
    const maxDist = joystick.clientWidth/2 - knob.clientWidth/2;
    const moveX = (deltaX / maxDist) * speed;
    const moveZ = (deltaY / maxDist) * speed;

    player.position.x += moveX;
    player.position.z += moveZ;

    // Limites para o jogador (para não sair da tela)
    if(player.position.x > 4) player.position.x = 4;
    if(player.position.x < -4) player.position.x = -4;
    if(player.position.z > 2) player.position.z = 2;
    if(player.position.z < -10) player.position.z = -10;

    // Move obstáculos para frente
    for(let i = obstacles.length-1; i>=0; i--){
      obstacles[i].position.z += 0.1;
      // Remove obstáculo se passar do player
      if(obstacles[i].position.z > 5){
        scene.remove(obstacles[i]);
        obstacles.splice(i,1);
      } else {
        // Checa colisão simples (distância)
        const dx = obstacles[i].position.x - player.position.x;
        const dz = obstacles[i].position.z - player.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);
        if(dist < 0.8){
          alert("Você bateu! Jogo terminado.");
          window.location.reload();
          return;
        }
      }
    }

    renderer.render(scene, camera);
  }

  animate();

  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>