<!DOCTYPE html>
<html lang="pt-br">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo 3D Inovador</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden; background: black;
    font-family: Arial, sans-serif;
    color: white;
    user-select: none;
    -webkit-user-select: none;
  }
  #score {
    position: fixed; top: 10px; left: 10px; font-size: 24px; z-index: 10;
  }
  #joystick {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 120px;
    height: 120px;
    touch-action: none;
    z-index: 10;
  }
</style>
</head>
<body>

<div id="score">Pontos: 0</div>
<div id="joystick"></div>

<script src="https://cdn.jsdelivr.net/npm/three@0.150.1/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/nipplejs@0.9.0/dist/nipplejs.min.js"></script>

<script>
  // === Setup básico Three.js ===
  const scene = new THREE.Scene();

  // Camera
  const camera = new THREE.PerspectiveCamera(70, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 15, 20);
  camera.lookAt(0, 0, 0);

  // Renderizador
  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luz
  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(10, 20, 10);
  scene.add(light);

  // Chão - plano escuro
  const floorGeo = new THREE.PlaneGeometry(30, 30);
  const floorMat = new THREE.MeshStandardMaterial({color: 0x111111});
  const floor = new THREE.Mesh(floorGeo, floorMat);
  floor.rotation.x = -Math.PI / 2;
  scene.add(floor);

  // Limites do campo (30x30 em X,Z)
  const LIMIT = 15;

  // Jogador - cubo verde
  const playerSize = 1.5;
  const playerGeo = new THREE.BoxGeometry(playerSize, playerSize, playerSize);
  const playerMat = new THREE.MeshStandardMaterial({color: 0x00ff00});
  const player = new THREE.Mesh(playerGeo, playerMat);
  player.position.y = playerSize/2;
  scene.add(player);

  // Variáveis controle
  let velocity = new THREE.Vector3(0,0,0);
  let speed = 0.2; // aumenta para ficar mais rápido

  // Projéteis
  const bullets = [];
  const bulletSpeed = 0.6;
  const bulletGeo = new THREE.SphereGeometry(0.3, 8, 8);
  const bulletMat = new THREE.MeshStandardMaterial({color: 0xffff00});

  // Inimigos
  const enemies = [];
  const enemyGeo = new THREE.SphereGeometry(1, 12, 12);
  const enemyMat = new THREE.MeshStandardMaterial({color: 0xff0000});
  const enemySpeedBase = 0.03;
  let enemySpawnInterval;
  let enemySpawnTime = 1500; // milissegundos

  // Pontuação
  let score = 0;
  const scoreDiv = document.getElementById('score');

  // Função reiniciar jogo
  function resetGame() {
    // Remove inimigos e tiros da cena e dos arrays
    bullets.forEach(b => scene.remove(b.mesh));
    enemies.forEach(e => scene.remove(e.mesh));
    bullets.length = 0;
    enemies.length = 0;
    score = 0;
    updateScore();
    player.position.set(0, playerSize/2, 0);
    startSpawning();
  }

  // Função spawn inimigo em borda aleatória
  function spawnEnemy() {
    // Escolhe borda: 0=x min,1=x max,2=z min,3=z max
    const side = Math.floor(Math.random()*4);
    let x, z;
    switch(side) {
      case 0: x = -LIMIT; z = (Math.random()*2 -1)*LIMIT; break;
      case 1: x = LIMIT;  z = (Math.random()*2 -1)*LIMIT; break;
      case 2: x = (Math.random()*2 -1)*LIMIT; z = -LIMIT; break;
      case 3: x = (Math.random()*2 -1)*LIMIT; z = LIMIT; break;
    }
    const enemy = {
      mesh: new THREE.Mesh(enemyGeo, enemyMat),
      velocity: new THREE.Vector3(),
    };
    enemy.mesh.position.set(x, 1, z);

    // Direção inimigo pro player (normalizada)
    const dir = new THREE.Vector3().subVectors(player.position, enemy.mesh.position).normalize();
    enemy.velocity.copy(dir).multiplyScalar(enemySpeedBase + Math.random()*0.02);
    scene.add(enemy.mesh);
    enemies.push(enemy);
  }

  // Atualizar pontuação
  function updateScore() {
    scoreDiv.textContent = 'Pontos: ' + score;
  }

  // Cria projétil na posição do player, disparado pra frente (direção para onde jogador está olhando)
  function shoot() {
    // Vamos fazer o tiro sair na frente do cubo no eixo Z (positivo)
    // Como o player não gira, disparo será sempre em direção z negativa (pra frente)
    const bullet = {
      mesh: new THREE.Mesh(bulletGeo, bulletMat),
      velocity: new THREE.Vector3(0, 0, -bulletSpeed),
    };
    bullet.mesh.position.set(player.position.x, player.position.y, player.position.z - playerSize);
    scene.add(bullet.mesh);
    bullets.push(bullet);
  }

  // Controle joystick usando nipplejs
  const joystickZone = document.getElementById('joystick');
  const joystick = nipplejs.create({
    zone: joystickZone,
    mode: 'static',
    position: { left: '60px', bottom: '60px' },
    color: 'white',
    size: 100,
  });

  let moveX = 0;
  let moveZ = 0;

  joystick.on('move', (evt, data) => {
    const distance = data.distance;
    const angle = data.angle ? data.angle.radian : 0;
    moveX = Math.cos(angle) * (distance / 50);
    moveZ = Math.sin(angle) * (distance / 50);
    // Limita max velocidade
    if (moveX > 1) moveX = 1;
    if (moveX < -1) moveX = -1;
    if (moveZ > 1) moveZ = 1;
    if (moveZ < -1) moveZ = -1;
  });

  joystick.on('end', () => {
    moveX = 0;
    moveZ = 0;
  });

  // Tocar na tela para atirar
  window.addEventListener('touchstart', e => {
    shoot();
  });

  // Lógica principal do jogo
  function animate() {
    requestAnimationFrame(animate);

    // Movimento do jogador pelo joystick, limitado dentro do campo
    player.position.x += moveX * speed;
    player.position.z += moveZ * speed;

    if (player.position.x > LIMIT) player.position.x = LIMIT;
    if (player.position.x < -LIMIT) player.position.x = -LIMIT;
    if (player.position.z > LIMIT) player.position.z = LIMIT;
    if (player.position.z < -LIMIT) player.position.z = -LIMIT;

    // Atualiza posição dos projéteis
    for (let i = bullets.length - 1; i >= 0; i--) {
      let b = bullets[i];
      b.mesh.position.add(b.velocity);

      // Remove se sair da área
      if (b.mesh.position.z < -LIMIT*2 || b.mesh.position.z > LIMIT*2 || b.mesh.position.x < -LIMIT*2 || b.mesh.position.x > LIMIT*2) {
        scene.remove(b.mesh);
        bullets.splice(i, 1);
        continue;
      }

      // Checa colisão projétil x inimigo
      for (let j = enemies.length - 1; j >= 0; j--) {
        let e = enemies[j];
        if (b.mesh.position.distanceTo(e.mesh.position) < 1) {
          // Remove inimigo e projétil
          scene.remove(e.mesh);
          scene.remove(b.mesh);
          enemies.splice(j, 1);
          bullets.splice(i, 1);
          score++;
          updateScore();
          break;
        }
      }
    }

    // Atualiza inimigos
    for (let e of enemies) {
      e.mesh.position.add(e.velocity);

      // Checa colisão inimigo x jogador
      if (e.mesh.position.distanceTo(player.position) < 1.5) {
        alert('Você perdeu! Pontuação final: ' + score);
        resetGame();
        return;
      }
    }

    renderer.render(scene, camera);
  }

  // Começar spawn inimigos
  function startSpawning() {
    if (enemySpawnInterval) clearInterval(enemySpawnInterval);
    enemySpawnInterval = setInterval(spawnEnemy, enemySpawnTime);
  }

  // Inicializa jogo
  resetGame();
  animate();

  // Ajuste tela
  window.addEventListener('resize', () => {
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
  });
</script>

</body>
</html>