<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Jogo 3D com tiro e joystick</title>
<style>
  body, html {
    margin: 0; padding: 0; overflow: hidden;
    background: #000;
    touch-action: none;
    user-select: none;
    font-family: Arial, sans-serif;
    color: white;
  }
  #score {
    position: fixed;
    top: 10px;
    left: 10px;
    font-size: 24px;
    font-weight: bold;
    z-index: 10;
  }
  #joystick {
    position: fixed;
    bottom: 30px;
    left: 30px;
    width: 120px;
    height: 120px;
    background: rgba(255,255,255,0.15);
    border-radius: 50%;
    touch-action: none;
    z-index: 10;
  }
  #knob {
    position: absolute;
    left: 40px; top: 40px;
    width: 40px; height: 40px;
    background: rgba(255,255,255,0.5);
    border-radius: 50%;
    touch-action: none;
  }
</style>
</head>
<body>

<div id="score">Pontos: 0</div>
<div id="joystick">
  <div id="knob"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>

<script>
  // --- Setup básico Three.js ---
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer({antialias: true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // Luzes
  const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambientLight);
  const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
  directionalLight.position.set(5,10,7);
  scene.add(directionalLight);

  // --- Personagem (cubo verde estilizado) ---
  const playerGeometry = new THREE.BoxGeometry(1,1,1);
  const playerMaterial = new THREE.MeshStandardMaterial({color: 0x00ff00, roughness: 0.5, metalness: 0.7});
  const player = new THREE.Mesh(playerGeometry, playerMaterial);
  scene.add(player);

  player.position.set(0, 0, 0);

  camera.position.set(0, 4, 8);
  camera.lookAt(player.position);

  // --- Projetil ---
  const projectileGeometry = new THREE.SphereGeometry(0.15, 8, 8);
  const projectileMaterial = new THREE.MeshStandardMaterial({color: 0xffff00});
  let projectiles = [];

  // --- Obstáculos variados ---
  const obstacleTypes = [
    {geometry: new THREE.SphereGeometry(0.3, 12, 12), color: 0xff0000},  // esfera vermelha
    {geometry: new THREE.ConeGeometry(0.3, 0.7, 8), color: 0x5555ff},    // cone azul
    {geometry: new THREE.TetrahedronGeometry(0.35), color: 0xff55ff},     // tetra roxo
  ];

  let obstacles = [];
  let obstacleSpeed = 0.1;

  function spawnObstacle(){
    const type = obstacleTypes[Math.floor(Math.random()*obstacleTypes.length)];
    const mat = new THREE.MeshStandardMaterial({color: type.color});
    const mesh = new THREE.Mesh(type.geometry, mat);

    mesh.position.x = (Math.random() - 0.5) * 8;
    mesh.position.z = -25;
    mesh.position.y = 0;

    scene.add(mesh);
    obstacles.push(mesh);
  }

  setInterval(spawnObstacle, 1200);

  // --- Joystick ---
  const joystick = document.getElementById('joystick');
  const knob = document.getElementById('knob');
  let dragging = false;
  let startX = 0, startY = 0;
  let deltaX = 0, deltaY = 0;

  joystick.addEventListener('touchstart', e => {
    dragging = true;
    const touch = e.touches[0];
    startX = touch.clientX;
    startY = touch.clientY;
  }, {passive:false});

  joystick.addEventListener('touchmove', e => {
    if(!dragging) return;
    const touch = e.touches[0];
    deltaX = touch.clientX - startX;
    deltaY = touch.clientY - startY;

    const maxDist = joystick.clientWidth/2 - knob.clientWidth/2;
    let dist = Math.sqrt(deltaX*deltaX + deltaY*deltaY);
    if(dist > maxDist){
      deltaX = deltaX * maxDist / dist;
      deltaY = deltaY * maxDist / dist;
    }

    knob.style.transform = `translate(${deltaX}px, ${deltaY}px)`;

    e.preventDefault();
  }, {passive:false});

  joystick.addEventListener('touchend', e => {
    dragging = false;
    deltaX = 0;
    deltaY = 0;
    knob.style.transform = `translate(0px, 0px)`;
  });

  // --- Movimento ---
  const playerSpeed = 0.12;
  const scoreDiv = document.getElementById('score');
  let score = 0;

  // --- Controle de disparo ---
  window.addEventListener('touchstart', e => {
    // Dispara tiro
    const projectile = new THREE.Mesh(projectileGeometry, projectileMaterial);
    projectile.position.copy(player.position);
    projectile.position.y = 0.5;
    scene.add(projectile);
    projectiles.push(projectile);
  });

  // --- Loop do jogo ---
  function animate(){
    requestAnimationFrame(animate);

    // Move player
    const maxDist = joystick.clientWidth/2 - knob.clientWidth/2;
    const moveX = (deltaX / maxDist) * playerSpeed;
    const moveZ = (deltaY / maxDist) * playerSpeed;

    player.position.x += moveX;
    player.position.z += moveZ;

    // Limites para player
    if(player.position.x > 4) player.position.x = 4;
    if(player.position.x < -4) player.position.x = -4;
    if(player.position.z > 3) player.position.z = 3;
    if(player.position.z < -10) player.position.z = -10;

    // Move obstáculos
    obstacles.forEach((obs, i) => {
      obs.position.z += obstacleSpeed;

      // Remove obstáculo se passar do player
      if(obs.position.z > 8){
        scene.remove(obs);
        obstacles.splice(i, 1);
      }

      // Colisão com player
      const dx = obs.position.x - player.position.x;
      const dz = obs.position.z - player.position.z;
      const dist = Math.sqrt(dx*dx + dz*dz);
      if(dist < 0.8){
        alert("Você bateu! Pontuação final: " + score);
        window.location.reload();
      }
    });

    // Move e checa projéteis
    projectiles.forEach((proj, i) => {
      proj.position.z -= 0.3;

      // Remove se sair da tela
      if(proj.position.z < -30){
        scene.remove(proj);
        projectiles.splice(i,1);
      }

      // Colisão projétil x obstáculos
      obstacles.forEach((obs, j) => {
        const dx = obs.position.x - proj.position.x;
        const dz = obs.position.z - proj.position.z;
        const dist = Math.sqrt(dx*dx + dz*dz);

        if(dist < 0.7){
          // Remove obstáculo e tiro
          scene.remove(obs);
          obstacles.splice(j, 1);

          scene.remove(proj);
          projectiles.splice(i, 1);

          score++;
          scoreDiv.textContent = "Pontos: " + score;
        }
      });
    });

    // Aumenta dificuldade gradativamente
    if(score > 0 && score % 10 === 0){
      obstacleSpeed = 0.1 + (score / 100);
    }

    renderer.render(scene, camera);
  }
  // Ajusta o tamanho da tela quando muda o tamanho da janela
window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth/window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});